---
layout: main
menu: Documentation
title: Documentation
css: [prettify]
---

<div class="row">
  <div class="span3 sidebar">
    <div class="sidenav affix-top" data-spy="affix" data-offset-top="140">
    <ul class="nav nav-list">
      <li><a href="#api">API documentation</a></li>
      <li class="nav-header">Concepts</li>
      <li><a href="#node_values">Node values</a></li>
      <li><a href="#iter_gen">Iterables</a></li>
      <li><a href="#async">Asynchronous functions</a></li>
      <li><a href="#optional_args">Optional arguments</a></li>
      <li class="divider"></li>
      <li class="nav-header">Migration</li>
      <li><a href="#migration_0.1.1_0.2.0">Migration from v0.1.1 to v0.2.0</a></li>
    </ul>
  </div>
  </div>
  <div class="span9">
    <section>
    <h3 id="api">API documentation</h3>
    <p>
    Documentation about all available methods can be found on the
    <a href="api/">API page</a>.
    </p>
    </section>
    <section>
      <h3 id="node_values">Node values: How different data types are handled</h3>
      <p>
        Node values are used internally as keys, e.g. 
        <code>nodeValue -> nodeAttribute</code> or <code>nodeValue -> neighbors</code>.
        There are also methods which return <code>nodeValue -> result</code> mappings,
        such as <code>G.degree()</code>.
      </p>
      <p>
        Since <span class="label label-info">v0.2.0</span>, instead of simple objects
        we use a custom Map implementation which preservers the actual node values.
        This is how different data types are treated:
      </p>
      <p>
        <strong>Numbers</strong> and <strong>strings</strong> work as expected:
        <pre class="prettyprint">
var G = jsnx.Graph();
G.add_nodes_from([1,2,3, "foo"]);
console.log(G.nodes());
// [1, 2, 3, "foo"]
</pre>
        <p>
        For everything else, such as <strong>objects</strong> and 
        <strong>arrays</strong> a string <em>key</em> is generated by calling 
        the object's <code>toString</code> method. This means that any two 
        objects are considered equal if their <code>toString</code> method 
        returns the same value. It also has the nice side-effect that simple 
        arrays (arrays containing primitive values, like numbers or string) 
        behave like Python's tuples.
        </p>
        <p>Examples:
        <pre class="prettyprint">
// Use arrays as tuples
var G = jsnx.Graph();
G.add_node([1,2], {data: 'foo'});
console.log(G.node.get([1,2]).data); // because [1,2].toString() === "1, 2"
// "foo"
</pre>
<div class="alert alert-warning">
  <strong>Note:</strong>
  The built-in array <code>toString</code> method does not format string values
  in any special way. That means that <code>[1,2]</code> and <code>["1","2"]</code>
  cannot be distinguished, since both produce the same string <code>"1, 2"</code>.
</div>

<pre class="prettyprint">
// Overwrite toString of objects
var nodeA = {toString: function() { return 'nodeA'; }};
var nodeB = {toString: function() { return 'nodeB'; }};

var G = jsnx.Graph();
G.add_nodes_from([nodeA, nodeB]);
console.log(G.nodes());
// [Object, Object]
</pre>
</p>

  <h3 id="iter_gen">Iterables</h3>
  <p>
  Many methods in JSNetworkX either accept or return an iterable/iterator. It
  follows the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iterable and Iterator</a> protocols of the next
  JavaScript version, ES2015.
  </p>
  <p>
  For example, each graph object is an iterable, which returns an iterator over
  its nodes:
  </p>
  <pre class="prettyprint linenums">
// ES2015 for/of loop to iterate over iterables
var G = jsnx.pathGraph(3);
for (var n of G) {
  console.log(n);
}
// logs 0, 1, 2
</pre>
  <p>
    In case you cannot use for/of loops, JSNetworkX exposes a <code>forEach</code>
    method to conveniently iterate over iterables:
  </p>
  <pre class="prettyprint linenums">
jsnx.forEach(G, function(n) {
  console.log(n);
});
</pre>
  <p>
    It also exposes a <code>toArray</code> method for converting iterables to
    arrays, in case the environment does not support <code>Array.from</code>:
  </p>
  <pre class="prettyprint linenums">
console.log(jsnx.toArray(jsnx.completeGraph(5)));
// [0, 1, 2, 3, 4]
</pre>

  <h3 id="async">Asynchronous Functions</h3>
  <p>
    Graph algorithms can take a long time to run, especially on larger graphs.
    This is usually not a problem for code running on the server (though it can
    be), but it is definitely a problem in the browser, where the run time per
    script is limited.
  </p>
  <p>
    To solve that issue, most algorithms are provided as synchronous and as asynchronous functions.
    The asynchronous function has the same name as the synchronous function,
    only prefixed with <code>gen</code>, and returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
  </p>
  <div class="alert alert-warning">
    <h5>IMPORTANT</h5>
    You may have to set <code>jsnx.workerPath</code> to the path of the
    <code>jsnetworkx.js</code> file in order for the WebWorker to work.
  </div>
  <p>
    In the browser, the asynchronous version will create a WebWorker, if available.
  </p>
  <p>
    In Node.js, the asynchronous version will spawn a new process.
  </p>
  <pre class="prettyprint linenums">
// synchronous
var cliques = jsnx.findCliques(G);

// asynchronous
jsnx.genFindCliques(G).then(function(cliques) {
  console.log(cliques);
});
</pre>

  <h3 id="optional_args">Optional arguments</h3>
  <p>Some methods have one or more optional arguments. Optional arguments can be omitted, as long as the arguments are of different types and therefore distinguishable.
  </p>

      <p> For example, this is OK:</p>
      <pre class="prettyprint linenums">
G.edges(true);
</pre>
      <p>but this is ambiguous:</p>
      <pre class="prettyprint linenums">
G.degree('weight'); // get node with name 'weight' or is the weight attribute name 'weight' ?
</pre>
      <p>In this case we decided to interpret the argument as node name. To set the <em>weight</em> attribute name and to get all nodes, <em>null</em> or <em>undefined</em> has to be passed as first argument:
      </p>
      <pre class="prettyprint linenums">
G.degree(null, 'weight');
</pre>
    </section>
    <section>
      <h3 id="migration_0.1.1_0.2.0">Migration from v0.1.1 to v0.2.0</h3>
      <p>
        <span class="label label-info">v0.1.1</span> had the disadvantage that
        every node value was implicitly converted to a string and the original
        value could not be restored (without additional, external logic).
      </p>
      <p>
        In <span class="label label-info">v.0.2.0</span>, instead of using simple
        objects to store node values, JSNetworkX uses instances of 
        <code>jsnx.contrib.Map</code>.
      </p>
      <p>
        This means that whenever a node was used as a property name,
        like
      </p> 
      <pre class="prettyprint">G.node[n]</pre> 
      <p>the <code>.get()</code> method has to be used instead:</p>
      <pre class="prettyprint">G.node.get(n)</pre>
      <p>Instead of assigning to the property:</p>
      <pre class="prettyprint">degrees[n] = 42;</pre>
      <p>the <code>.set()</code> method has to be used:</p>
      <pre class="prettyprint">degress.set(n, 42);</pre>
      
      <p>
        If you use any of the following properties or methods, then you will have
        to adjust the code accordingly.
      </p>
      <p>
        <strong>Changed properties</strong><br>
        These properties hold a map instead of an object keyed by node.
      </p> 
      <ul>
        <li>Graph#node</li>
        <li>Graph#adj</li>
        <li>Graph#edge</li>
        <li>DiGraph#succ</li>
        <li>DiGraph#pred</li>
      </ul>
      <p>
        <strong>Changed methods/functions</strong><br>
        These methods/functions return a map instead of an object keyed by
        node or edge.
      </p> 
      <ul>
        <li>Graph#degree</li>
        <li>Graph#get (previously Graph#get_node)</li>
        <li>DiGraph#in_degree</li>
        <li>DiGraph#out_degree</li>
        <li>jsnx.all_pairs_shortest_path</li>
        <li>jsnx.all_pairs_shortest_path_length</li>
        <li>jsnx.betweenness_centrality</li>
        <li>jsnx.clustering</li>
        <li>jsnx.degree</li>
        <li>jsnx.edge_betweenness_centrality</li>
        <li>jsnx.get_edge_attributes</li>
        <li>jsnx.get_node_attributes</li>
        <li>jsnx.number_of_cliques</li>
        <li>jsnx.predecessor</li>
        <li>jsnx.single_source_shortest_path</li>
        <li>jsnx.single_source_shortest_path_length</li>
        <li>jsnx.square_clustering</li>
        <li>jsnx.triangles</li>
      </ul>

      <p>
        No adjustments have to be made for graph creation. The following
        will still work as expected, because numeric property names of objects 
        containing node data are implicitly converted to numbers.
      </p>
<pre class="prettyprint">
var G = jsnx.Graph({1: [2, 3], 2: [3]});
</pre>
    </section>
  </div>
</div>
<script src="javascripts/prettify.js"></script>
<script>
  window.prettyPrint && window.prettyPrint();
</script>
