---
layout: main
menu: Getting Started
title: "Getting Started"
sub: "Your first steps with JSNetworkX"
css: [prettify, getting_started]
---

<div class="row">
  <div class="span3 sidebar">
    <ul class="nav nav-list sidenav" data-spy="affix" data-offset-top="240">
      <li><a href="#install">Installation</a></li>
      <li><a href="#create">Create a graph</a></li>
      <li><a href="#nodes_edges">Nodes and edges</a></li>
      <li><a href="#data">Node and edge data</a></li>
      <li><a href="#analysis">Analyzing graphs</a></li>
      <li><a href="#drawing">Drawing</a></li>
    </ul>
    <div id="demo-canvas" class="sidenav" data-spy="affix" data-offset-top="165"></div>
  </div>
  <div class="span9">
  <section id="install">
    <h2 class="page-header">Installation</h2>
<h3>Browser</h3>
<p>Download <a href="https://github.com/fkling/JSNetworkX/blob/master/jsnetworkx.js">jsnetworkx.js</a> and include it in your page:</p>
<pre class="prettyprint linenums">
&lt;script src="jsnetworkx.js&gt;&lt;/script&gt;
</pre>
<p>
There are several <a href="https://github.com/fkling/JSNetworkX/blob/master/dist/">other version</a> for you to choose from. These
are:</p>
<ul>
  <li>
    <code>jsnetworkx-base.js</code>: Contains only graph classes and utility functions, no algorithms, graph generators, visualization etc.
  </li>
  <li>
    <code>jsnetworkx-drawing.js</code>: Like the base version, but with visualization.
  </li>
  <li>
    <code>jsnetworkx-node.js</code>: A special Node.js version with all modules but without visualization.
  </li>
</ul>

<div class="alert alert-info">
<strong>Note</strong> Even though the "base" version does not include 
algorithms explicitly, some might be included due to internal dependencies.
</div>

<p>You can even <a href="https://github.com/fkling/JSNetworkX#how-to-build">build your own version</a> and decide which modules to include.</p>

<p>
If you want to <a href="https://github.com/fkling/JSNetworkX/wiki/Drawing-graphs">visualize graphs</a>, 
you have to include <a href="http://d3js.org/">D3.js</a> as well.<br>
<span class="label label-important">Important</span> It seems that <a href="https://github.com/mbostock/d3/tree/v2.9.3">d3 version 2.9.3</a> works most reliably if you want to use the force layout and be able to drag nodes and pan the canvas.
</p>

<h3>Node.js</h3>

<p>Install JSNetworkX with</p>

<pre class="prettyprint linenums">
npm install <span class="nocode">https://github.com/fkling/JSNetworkX.git</span>
</pre>

<p>and import it in your application</p>
<pre class="prettyprint linenums">
var jsnx = require('jsnetworkx');
</pre>

<p>The package will be made available as official node module once it reaches a certain level of completeness.</p>
</section>
<section id="create">
<h2 class="page-header">Create a graph</h2>
  <p><em>If you are already familiar with NetworkX, than most of the following 
  information will already be familiar to you. Most (if not all) method and function names are the same as in NetworkX.</em></p>

<p>Once you included JSNetworkX you can start working with graphs. If you are 
working in a browser environment, including jsnetworkx.js will create a global 
variable <code>jsnx</code>, which is an object. All functions/methods/modules 
are properties of this object. In Node.js use the name of variable you assigned 
the module to.
</p>

<p>There are basically three ways to create a new graph:</p>
<ol>
  <li>By calling the <code>Graph</code> constructor or one of its subclasses (<code>DiGraph</code>, <code>MultiGraph</code> or <code>MultiDiGraph</code>).</li>
  <li>By transforming an existing graph into a new graph, for example by creating 
  a subgraph with <code>G.subgraph</code> or convert an undirected graph to a directed one (<code>G.to_directed</code>).</li>
  <li>With a graph generator, such as <code>complete_graph().</code></li>
</ol>

<p>Here are some examples:</p>
<pre class="prettyprint linenums">
// This creates a new empty, undirected graph
var G = new jsnx.Graph();
// you can even omit the `new` keyword
var G = jsnx.Graph();

// Generates a complete graph with six nodes
var G = jsnx.complete_graph(6);

// Generates a random graph with six nodes and
// an edge between each node is created with a probability of 0.3
var G = jsnx.binomial_graph(6, 0.3);
</pre>

<p>JSNetworkX provides support for four types of graphs: 
<a href="http://en.wikipedia.org/wiki/Undirected_graph#Undirected_graph">undirected graphs</a> ( <code>Graph</code>),
<a href="http://en.wikipedia.org/wiki/Directed_graph">directed graphs</a> (<code>DiGraph</code>), 
<a href="http://en.wikipedia.org/wiki/Multi-edge">multi edge undirected graphs</a> 
(<code>MultiGraph</code>) and multi edge directed graphs ( <code>MultiDiGraph</code>). 
Each type provides specific methods to access and extract information about the 
structure of the graph.
</p>
</section>
<section id="nodes_edges">
  <h2 class="page-header">Nodes and edges</h2>

  <p>Once we obtained a graph, we want to modify it, by adding or removing nodes and edges, or access node and edge information.</p>

  <h4>Adding and removing nodes</h4>
  <p>Single nodes can be added with <code>G.add_node</code> and a collection 
  of nodes with <code>G.add_nodes_from</code>. Typically the collection will 
  be an array, but it could be another graph as well, or any node collection
  returned by another library function.<br>
  Lets have a look at an example and let us print the nodes:
  </p>
<pre class="prettyprint linenums" data-example="run" data-draw="true">
var G = jsnx.Graph();
G.add_node(1);
G.add_nodes_from([3, 5, 7, 11]);
console.log(G.nodes());
// shows ["1", "3", "5", "7", "11"]
</pre>
<p><code>G.nodes</code> returns an array nodes, which shows us that The graph 
has now four nodes, namely 1, 3, 5 and 7.
</p>
<div class="alert alert-block alert-warning">
  <h4>Node data type: String</h4>
  <p>
  You will notice that the array of nodes consists of <em>strings</em> although we 
  added <em>numbers</em>. This is a limitation the library currently has. Any value you 
  pass as node will be converted to a string. This should generally not be a
  problem if you know what data you are working with, but nevertheless, 
  we are working on <strong>support for generic node values</strong>
  </p>
</div>
<p>Removing nodes is as simple as adding them. You can use either <code>G.remove_node</code>
or <code>G.remove_nodes_from </code>. 

<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="0">
G.remove_node(11); // same as G.remove_node("5");
console.log(G.nodes());
// shows ["1", "3", "5", "7"]
</pre>
<div class="alert alert-info">
<strong>Info:</strong> Removing a node will also remove all connected edges.
</div>
<h4>Adding and removing edges</h4>
<p>Adding and removing edges works pretty much the same way, with the methods 
<code>G.add_edge</code> which accepts two nodes as arguments, and 
<code>G.add_edges_from</code> which accepts a list of 2-tuples (arrays).
</p>
<div class="alert alert-info">
  <strong>Info:</strong> If you add an edge between non-existing nodes, the nodes
  will automatically be created.
</div>
<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="1">
G.add_edge(1,3);
G.add_edge(3, 1); // does not do anything in undirected graphs
G.add_edges_from([[1,5], [1,7], [7,3], [7,9]]); // node 9 does not exist!
console.log(G.nodes());
// shows ["1", "3", "5", "7", "9"]
console.log(G.edges());
// shows [["1", "3"], ["1", "5"], ["1", "7"], ["7", "3"], ["7", "9"]]
</pre>
<p>
Edges are removed with <code>G.remove_edge</code> and <code>G.remove_edges_from</code>.
</p>
<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="2">
G.remove_edge(5,1); // or G.remove_edge(1,5);
G.remove_edges_from([[9,7], [7,1]]);
// Removing a node removes its connected edges as well
G.remove_node(3);
console.log(G.nodes());
// shows ["1", "5", "7", "9"]
console.log(G.edges());
// shows []
</pre>
</section>
<section id="data">
  <h2 class="page-header">Node and edge data</h2>
  <p>A great feature of NetworkX is the possibility to assign any data to nodes
  and edges and of course JSNetworkX allows you to do this too.</p>

  <h4>New nodes, edges</h4>
  <p><code>G.add_node</code>
  accepts an object as second argument. This will be the node's data. Similarly, 
  <code>G.add_nodes_from</code> accepts a list of <strong>2-tuples</strong>, 
  where the first element is the node, and the second element is a data object.
  It also accepts an object as second argument. Data passed through this object 
  will be added to all nodes.
  </p>
<pre class="prettyprint linenums">
var G = jsnx.Graph();
// Adds a new node, 10, with the data {some_data: 42}
G.add_node(10, {some_data: 42});

// Adds the nodes, "foo" and "bar", with individual data and data for both nodes
G.add_nodes_from([['foo', {size: 5}], ['bar', {size: 10}]], {color: 'blue'});

// Passing `true` to `G.nodes` changes the return value to include the data for each node
console.log(G.nodes(true));
// shows
// [
//    ["10",{"some_data":42}],
//    ["foo",{"color":"blue","size":5}],
//    ["bar",{"color":"blue","size":10}]
// ]
</pre>
<p>It works the same for edges: <code>G.add_edge</code> accepts an object as third
argument and <code>G.add_edges_from</code> a list of 3-tuples, where the first two
elements are nodes and the third one is a data object.</p>

<h4>Existing nodes, edges</h4>
<p> You have two ways to set data on <em>existing</em> nodes and edges: 
Either just add the node (edge) again, the passed data will be <strong>merged</strong>,
or access the nodes (edges) via the graphs <code>G.node</code> (<code>G.adj</code>)
properties.
</p>
<pre class="prettyprint linenums">
var G = jsnx.Graph();
G.add_nodes_from([0,1]);
G.add_edge(0,1);

G.node[0].foo = 'bar';
G.adj[0][1].color = 'blue'; // or G.adj[1][0].color =  ...

console.log(G.nodes(true));
// shows [["0",{"foo":"bar"}],["1",{}]]
console.log(G.edges(true));
// shows [["0","1",{"color":"blue"}]]
</pre>

<div class="alert"><strong>Warning</strong> 
  You should directly modify the <code>G.nodes</code> or <code>G.adj</code> 
  properties, since this can lead to inconsistency within the graph.
</div>
<div class="alert alert-error">
  <h4>Upcoming API changes</h4>
  <p>In order to support generic node values, the <code>G.nodes</code>, 
  <code>G.adj</code> and other related properties won't stay simple objects. 
  You should not rely on them too much or at least be prepared that they will change.
  They will be changed to some kind of maps, like
  <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-15.14">ES6's Map objects</a>.
  </p>
</div>

<h4>What is this data useful for?</h4>
<p>That is really up to your use case. For example, if you are modeling a social
network, the node data can contain more detailed information about a person.
If you are modeling a street network, the edge data could contain timeseries data
about congestion.
</p>
<p>Node and edge data can be very useful if you want to customize the style of 
nodes and edges in a visualization. This will be explained later, but here is 
already a short example of how this can look like:
</p>
<pre class="prettyprint linenums" data-example="run" data-draw="false">
var G = jsnx.Graph();
G.add_nodes_from([
    [1, {color: 'red'}],
    [2, {color: 'green'}],
    [3, {color: 'white'}]
]);

G.add_edges_from([[1,2], [1,3]]);

// `jsnx.draw` accept a graph and configuration object
jsnx.draw(G, {
  element: '#demo-canvas',
  with_labels: true,
  node_style: {
      fill: function(d) {
          return d.data.color;
      }
  }
});
</pre>
</section>
<section id="analysis">
  <h2 class="page-header">Analyzing graphs</h2>
  <p>NetworkX provides a variety of algorithms to analyze graphs, such as detecting
  cliques, computing shortest paths or the centrality of a graph. JSNetworkX 
  aims to provide those algorithms as well. You can see the progress and which
  algorithms are available on the <a href="api_progress.html">API progress page</a>.
  To learn about the algorithms which are generally available, have a look at the 
  <a href="http://networkx.github.com/documentation/latest/reference/algorithms.html">NetworkX documentation</a>.
  </p>

  <p>Most functions implementing those algorithms are available on the
  <code>jsnx</code> object (just like with NetworkX). Here is a small example, 
  which computes the shortest path between two nodes, draws the graph and colors 
  the found nodes differently.
  </p>
<pre class="prettyprint linenums" data-example="run" data-draw="false">
// This is a graph generator
var G = jsnx.cycle_graph(6);
// Compute the shortest path between 0 and 4
var path = jsnx.bidirectional_shortest_path(G, 0, 4);
// A simple way to color all nodes in the path:
G.add_nodes_from(path, {color: '#FFF'});
// Color the start and end differently
G.node[0].color = '#0F0'; // start is green
G.node[4].color = '#F00'; // end is red

jsnx.draw(G, {
  element: '#demo-canvas',
  with_labels: true,
  node_style: {
    fill: function(d) {
      return d.data.color || '#AAA'; // any node without color is gray
    }
  }
});
</pre>
</section>
<section id="drawing">
  <h2 class="page-header">Drawing graphs</h2>
  <div class="alert alert-info">
  <strong>Info</strong> 
  The drawing API is not finalized yet and will be extended greatly to make it
  easier to customize and modify visualizations.
  </div>

  <p>You already have seen some examples of how to draw graphs. Here is a more
  detailed introduction.</p>

  <p>JSNetworkX uses <a href="http://d3js.org/">d3.js</a> to draw graphs as SVG.
  d3 is a very powerful library to bind data to DOM elements and provides many useful
  methods for data visualization. You are encouraged to learn more about it to 
  get the most out of drawing graphs.  JSNetworkX takes care of setting up the 
  connections between the graph, the layout and the SVG elements, and lets you 
  apply custom styles to nodes and edges.
  </p>

  <p><code>jsnx.draw</code> is the method with which you can draw a graph and
  it accepts the following arguments:
  </p>
<pre>
jsnx.draw(G, options [, update]);
</pre>
  <ul>
    <li><code>G</code> can be either a directed or undirected graph. Multi edge graphs are not supported.</li>
    <li><code>options</code> is an object which controls the look and behavior of the visualization.</li>
    <li><code>update</code> is a boolean value and controls whether modifications to the graph should be reflects in the visualization.</li>
  </ul>

 <h4>Drawing options</h4>
 <p>A complete list of options with explanation can be found 
 <a href="https://github.com/fkling/JSNetworkX/wiki/Drawing-graphs">in the wiki</a>.
 In the following we will describe the most important options and concepts you need to know about.
 </p>
 <p>The only <em>required</em> option is <code>element</code>, so that the library
 knows where to draw the graph. It can either be a CSS selector or a DOM element.
 Internally, the method uses <code>d3.select</code> to select the element.
 </p>
 <p><code>jsnx.draw</code> will add a new <code>&lt;svg&gt;</code> container to
 the element, which by default has the same width and height as its parent. You
 can explicitly set the dimensions by specifying the <code>width</code> and
 <code>height</code> options.
 </p>
 <p>The most interesting options are probably <code>node_style</code>,
 <code>node_attr</code>, <code>edge_style</code> and <code>edge_attr</code>, which
 with you can specify the look of nodes and edges. Since the graph is drawn
 with SVG elements, the <code>*_style</code> options should hold values for 
 CSS properties and the <code>*_attr</code> options values for element attributes.
 If you are not very familiar with SVG, have a look at the <a href="https://developer.mozilla.org/en/docs/SVG">MDN SVG documentation</a>.
 The options are explained in greater detail in the next section.
 </p>
 <h4>Data binding and styling</h4>
 <p>As mentioned earlier, d3's main feature is the <a href="http://mbostock.github.com/d3/tutorial/circle.html">binding of data to DOM elements</a>.
 This is also the foundation for the graph visualization: Each SVG element
 representing a node or edge has an object bound to it, with various information.
 <br>
 By using a function as one of the style or attribute values, you will have access to that information,
 because internally, the library just passes the values along to
 d3's <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style"><code>.style</code> and</a>
 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr"><code>.attr</code> methods</a>.
 </p>
 <p>The data object bound to an element for a node has the following properties:</p>
 <ul>
   <li><code>node</code>, the node value</li>
   <li><code>data</code>, the node data from the graph (see <a href="#data">Node and edge data</a>)</li>
   <li><code>G</code>, a reference to the graph object
  </ul>
  <p>The data object for an edge has similar properties:</p>
 <ul>
   <li><code>edge</code>, a 2-tuple (array) containing the nodes this edge connects</li>
   <li><code>data</code>, the edge data from the graph (see <a href="#data">Node and edge data</a>)</li>
   <li><code>G</code>, a reference to the graph object
  </ul>
  <p>To better illustrate this concept, here is a small example: Each node in 
  the graph has a property <code>count</code>. We will later use this
  property to draw the nodes in different sizes. The nodes are drawn as 
  <code>&lt;circle&gt;</code> SVG elements and the radius is controlled by the
  elements <code>r</code> <strong>attribute</strong>. Hence we have to use the
  <code>node_attr</code> option.
</p>
<pre class="prettyprint linenums" data-example="run" data-draw="false">
var G = jsnx.Graph();
G.add_node(1, {count: 12});
G.add_node(2, {count: 8});
G.add_node(3, {count: 15});
G.add_edges_from([[1,2],[2,3]]);

jsnx.draw(G, {
  element: '#demo-canvas',
  with_labels: true,
  node_attr: {
    r: function(d) {
      // `d` has the properties `node`, `data` and `G`
      return d.data.count;
    }
  }
});
</pre>
  <h4>Graph layouts</h4>
  <p>JSNetworkX currently only supports a <a href="https://github.com/mbostock/d3/wiki/Force-Layout">force based layout</a> but
  we will add other layouts in the future.
  </p>
<h4>Limitations and other drawing techniques</h4>
<p>SVG has its pros and cons. It is easier to add interaction but there is an
upper limit of how elements can be drawn, which depends a lot on the user's 
computer and browser.
</p>
<p>We aim to support different drawing techniques, like canvas and WebGL and with 
the expectation that this will allow us to draw larger graphs reasonably well.
</p>
</section>
  </div>
</div>
<script src="javascripts/prettify.js"></script>
<script>
  window.prettyPrint && window.prettyPrint();
  $('body').scrollspy();
</script>
<script src="javascripts/demo.js"></script>
